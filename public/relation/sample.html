<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pecha Relationship Sample Graph</title>
    <link rel="stylesheet" href="relation.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #graph-container {
            width: 100%;
            height: 800px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 15px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #e0e0e0;
        }
        .insights {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
    </style>
</head>
<body>
    <h1>Pecha Relationship Network Visualization</h1>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="border: 3px solid var(--version-color)"></div>
            <span>Version Relationship</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="border: 3px solid var(--commentary-color)"></div>
            <span>Commentary Relationship</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="border: 3px solid var(--translation-color)"></div>
            <span>Translation Relationship</span>
        </div>
    </div>
    
    <div class="controls">
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="reset-view">Reset View</button>
    </div>
    
    <div id="graph-container"></div>
    
    <div class="insights">
        <h3>Graph Insights:</h3>
        <ul>
            <li><strong>Central Text:</strong> "ཤེས་རབ་ཀྱི་ཕ་རོལ་ཏུ་ཕྱིན་པའི་སྙིང་པོ།" (I5339F440) appears to be the root text.</li>
            <li><strong>Versions:</strong> There are 5 different versions of the root text.</li>
            <li><strong>Commentaries:</strong> There are 6 different commentaries on various versions.</li>
            <li><strong>Translations:</strong> There are 2 translations (Chinese and Sanskrit).</li>
            <li><strong>Structure:</strong> The network shows a hierarchical structure with the root text at the center.</li>
        </ul>
    </div>

    <script>
        // Sample data of related pechas
        const relationshipData = [
          {
            "id": "I4CAEB6F6",
            "title": "般若波羅蜜多心經",
            "translation_of": "IA9A888A5"
          },
          {
            "commentary_of": "I9943B599",
            "id": "I22734F80",
            "title": "བཻ་རོ་ཙ་ན། ཤེར་སྙིང་འགྲེལ་པ་སྔགས་སུ་བཀྲལ་པ།"
          },
          {
            "commentary_of": "I85E31AAE",
            "id": "I70BA77E2",
            "title": "ཕྱག་ན་རྡོ་རྗེ། ཤེར་ཕྱིན་སྙིང་པོའི་འགྲེལ་པ།"
          },
          {
            "commentary_of": "I63332C79",
            "id": "I865C243B",
            "title": "ཤེར་ཕྱིན་སྙིང་པོའི་མདོའི་ཚིག་འགྲེལ་རྨད་དུ་བྱུང་བ་བཞུགས།"
          },
          {
            "commentary_of": "I02DEEEA9",
            "id": "I7D9965EE",
            "title": "ཏཱ་ར་ནཱ་ཐ། ཤེས་རབ་སྙིང་པོའི་ཚིག་འགྲེལ།"
          },
          {
            "id": "IA9A888A5",
            "title": "ཤེས་རབ་ཀྱི་ཕ་རོལ་ཏུ་ཕྱིན་པའི་སྙིང་པོ།",
            "version_of": "I5339F440"
          },
          {
            "id": "I9943B599",
            "title": "ཤེས་རབ་སྙིང་པོ།",
            "version_of": "I5339F440"
          },
          {
            "id": "I85E31AAE",
            "title": "ཤེས་རབ་སྙིང་པོ།",
            "version_of": "I5339F440"
          },
          {
            "commentary_of": "I5339F440",
            "id": "I7633E424",
            "title": "ཤེར་སྙིང་འགྲེལ་པ་སྔགས་སུ་བཀྲལ་པ།"
          },
          {
            "commentary_of": "I5339F440",
            "id": "I66A6C5F6",
            "title": "ཤེར་ཕྱིན་སྙིང་པོའི་འགྲེལ་པ་དོན་གྱི་སྒྲོན་མ།"
          },
          {
            "id": "I63332C79",
            "title": "ཤེས་རབ་སྙིང་པོ།",
            "version_of": "I5339F440"
          },
          {
            "id": "I542210F9",
            "title": "प्रज्ञापारमिताहृदय",
            "translation_of": "I5339F440"
          },
          {
            "id": "I02DEEEA9",
            "title": "ཤེས་རབ་སྙིང་པོ།",
            "version_of": "I5339F440"
          },
          {
            "id": "I5339F440",
            "title": "ཤེས་རབ་ཀྱི་ཕ་རོལ་ཏུ་ཕྱིན་པའི་སྙིང་པོ།"
          }
        ];

        class PechaGraphSample {
            constructor() {
                this.relationshipColors = {
                    version_of: '#4CAF50',     // Green for version
                    commentary_of: '#FF9800',  // Orange for commentary
                    translation_of: '#E91E63', // Pink for translation
                };
                
                this.state = {
                    width: document.getElementById('graph-container').clientWidth,
                    height: document.getElementById('graph-container').clientHeight,
                    zoom: null,
                    simulation: null
                };
                
                this.initializeGraph();
                this.setupControls();
                
                const graphData = this.processRelationshipData(relationshipData);
                this.renderGraph(graphData);
            }
            
            initializeGraph() {
                // Clear any existing SVG
                d3.select('#graph-container svg').remove();
                
                // Create SVG container
                const svg = d3.select('#graph-container')
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${this.state.width} ${this.state.height}`)
                    .attr('preserveAspectRatio', 'xMidYMid meet');
                
                // Create zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                this.state.zoom = zoom;
                
                // Create a group for the graph elements
                const g = svg.append('g');
                
                // Create tooltip div
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'node-tooltip')
                    .style('opacity', 0);
                
                return { svg, g, tooltip };
            }
            
            setupControls() {
                const zoomIn = document.getElementById('zoom-in');
                const zoomOut = document.getElementById('zoom-out');
                const resetView = document.getElementById('reset-view');
                
                zoomIn.addEventListener('click', () => {
                    d3.select('#graph-container svg').transition().duration(300)
                        .call(this.state.zoom.scaleBy, 1.5);
                });
                
                zoomOut.addEventListener('click', () => {
                    d3.select('#graph-container svg').transition().duration(300)
                        .call(this.state.zoom.scaleBy, 0.75);
                });
                
                resetView.addEventListener('click', () => {
                    d3.select('#graph-container svg').transition().duration(300)
                        .call(this.state.zoom.transform, d3.zoomIdentity);
                });
            }
            
            processRelationshipData(data) {
                // Convert the flat list into a network structure
                const nodes = [];
                const links = [];
                const nodeMap = new Map();
                
                // Find the central node (I5339F440) which appears to be the root text
                const rootId = 'I5339F440';
                
                // First pass: Create all nodes
                data.forEach(item => {
                    if (!nodeMap.has(item.id)) {
                        const node = {
                            id: item.id,
                            title: item.title,
                            group: 'related' // Default group
                        };
                        
                        // Set the root node as selected
                        if (item.id === rootId) {
                            node.group = 'selected';
                        }
                        
                        nodes.push(node);
                        nodeMap.set(item.id, node);
                    }
                });
                
                // Remove duplicate nodes (there seems to be a duplicate in the data)
                const uniqueNodes = [];
                const seenIds = new Set();
                
                nodes.forEach(node => {
                    if (!seenIds.has(node.id)) {
                        uniqueNodes.push(node);
                        seenIds.add(node.id);
                    }
                });
                
                // Second pass: Create links and set node types based on relationship
                data.forEach(item => {
                    // Check for version relationship
                    if (item.version_of) {
                        const targetNode = nodeMap.get(item.id);
                        if (targetNode) {
                            targetNode.group = 'version';
                            
                            links.push({
                                source: item.version_of,
                                target: item.id,
                                type: 'version'
                            });
                        }
                    }
                    
                    // Check for commentary relationship
                    if (item.commentary_of) {
                        const targetNode = nodeMap.get(item.id);
                        if (targetNode) {
                            targetNode.group = 'commentary';
                            
                            links.push({
                                source: item.commentary_of,
                                target: item.id,
                                type: 'commentary'
                            });
                        }
                    }
                    
                    // Check for translation relationship
                    if (item.translation_of) {
                        const targetNode = nodeMap.get(item.id);
                        if (targetNode) {
                            targetNode.group = 'translation';
                            
                            links.push({
                                source: item.translation_of,
                                target: item.id,
                                type: 'translation'
                            });
                        }
                    }
                });
                
                return { nodes: uniqueNodes, links };
            }
            
            renderGraph(data) {
                if (!data) return;
                
                console.log('Rendering graph with nodes:', data.nodes.length, 'links:', data.links.length);
                
                const { svg, g, tooltip } = this.initializeGraph();
                
                // Create force simulation
                const simulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(data.links).id(d => d.id).distance(200))
                    .force('charge', d3.forceManyBody().strength(-800))
                    .force('center', d3.forceCenter(this.state.width / 2, this.state.height / 2))
                    .force('collision', d3.forceCollide().radius(120));
                    
                // Create arrow marker definitions for the links
                svg.append('defs').selectAll('marker')
                    .data(['version', 'commentary', 'translation', 'related'])
                    .enter().append('marker')
                    .attr('id', d => `arrow-${d}`)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 30) // Position the arrow away from the node
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', d => {
                        if (d === 'version') return this.relationshipColors.version_of;
                        if (d === 'commentary') return this.relationshipColors.commentary_of;
                        if (d === 'translation') return this.relationshipColors.translation_of;
                        return '#555';
                    });
                    
                // Create links - using paths with arrows instead of simple lines
                const link = g.append('g')
                    .attr('class', 'links')
                    .selectAll('path')
                    .data(data.links)
                    .enter().append('path')
                    .attr('class', d => `link link-${d.type}`)
                    .attr('marker-end', d => `url(#arrow-${d.type})`);
                    
                // Create nodes
                const node = g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('.node')
                    .data(data.nodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on('start', this.dragstarted.bind(this, simulation))
                        .on('drag', this.dragged.bind(this))
                        .on('end', this.dragended.bind(this, simulation)));
                
                // Calculate node dimensions based on text length
                const calculateNodeDimensions = (d) => {
                    const idLength = d.id.length;
                    const titleText = d.title || 'Untitled';
                    const titleLength = titleText.length;
                    // Ensure the width is at least enough to show the full ID
                    const width = Math.max(idLength * 9, titleLength * 6, 150);
                    return {
                        width: width,
                        height: 50,
                        title: titleText
                    };
                };
                
                // Add rectangles to nodes
                node.each(function(d) {
                    const dimensions = calculateNodeDimensions(d);
                    d.width = dimensions.width;
                    d.height = dimensions.height;
                    d.fullTitle = dimensions.title;
                    
                    d3.select(this).append('rect')
                        .attr('class', `node-rect ${d.group}`)
                        .attr('width', d.width)
                        .attr('height', d.height)
                        .attr('rx', 10)
                        .attr('ry', 10)
                        .attr('x', -d.width / 2)
                        .attr('y', -d.height / 2);
                });
                
                // Add ID text labels to nodes
                node.append('text')
                    .attr('class', 'node-id')
                    .attr('dy', -10)
                    .text(d => d.id)
                    .attr('text-anchor', 'middle');
                
                // Add title text labels to nodes with ellipsis if needed
                node.append('text')
                    .attr('class', 'node-title')
                    .attr('dy', 15)
                    .text(d => {
                        const title = d.fullTitle;
                        const maxLength = Math.floor(d.width / 6);
                        if (title.length > maxLength) {
                            return title.substring(0, maxLength - 3) + '...';
                        }
                        return title;
                    })
                    .attr('text-anchor', 'middle');
                
                // Add hover effects and tooltip
                node.on('mouseover', (event, d) => {
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);
                    
                    const tooltipContent = `
                        <strong>ID:</strong> ${d.id}<br>
                        <strong>Title:</strong> ${d.fullTitle || 'Untitled'}
                    `;
                    
                    tooltip.html(tooltipContent)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', () => {
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);
                });
                
                // Update positions on each tick of the simulation
                simulation.on('tick', () => {
                    // Create curved paths for links
                    link.attr('d', function(d) {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        
                        // Return a curved path
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });
                    
                    node
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                });
                
                // Store simulation reference
                this.state.simulation = simulation;
            }
            
            dragstarted(simulation, event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            dragended(simulation, event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Initialize the graph when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PechaGraphSample();
        });

        // Start the graph immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            new PechaGraphSample();
        }
    </script>
</body>
</html>
